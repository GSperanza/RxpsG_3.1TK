% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/XPSClass.r
\docType{class}
\name{hasBoundaries}
\alias{hasBoundaries}
\alias{hasBoundaries,XPSCoreLine-method}
\alias{hasRegionToFit}
\alias{hasRegionToFit,XPSCoreLine-method}
\alias{hasBaseline}
\alias{hasBaseline,XPSCoreLine-method}
\alias{hasComponents}
\alias{hasComponents,XPSCoreLine-method}
\alias{hasFit}
\alias{hasFit,XPSCoreLine-method}
\alias{show,XPSCoreLine-method}
\alias{setAsData.Frame}
\alias{setAsData.Frame,XPSCoreLine-method}
\alias{setAsMatrix}
\alias{setAsMatrix,XPSCoreLine-method}
\alias{asList}
\alias{asList,XPSCoreLine-method}
\alias{sortComponents}
\alias{sortComponents,XPSCoreLine-method}
\alias{getMaxOfComponents}
\alias{getMaxOfComponents,XPSCoreLine-method}
\alias{XPSsetRegionToFit}
\alias{XPSsetRegionToFit,XPSCoreLine-method}
\alias{baseline-class}
\alias{XPSbaseline}
\alias{XPSbaseline,XPSCoreLine-method}
\alias{XPSapplyshift}
\alias{XPSapplyshift,XPSCoreLine-method}
\alias{XPSremove}
\alias{XPSremove,XPSCoreLine-method}
\alias{XPSsetRSF}
\alias{XPSsetRSF,XPSCoreLine-method}
\alias{XPScalc}
\alias{XPScalc,XPSCoreLine-method}
\alias{XPSpkgCtrl}
\alias{XPSpkgCtrl,XPSCoreLine-method}
\alias{plot,XPSCoreLine,missing-method}
\alias{XPSresidualPlot}
\alias{XPSresidualPlot,XPSCoreLine-method}
\alias{XPSSample-class}
\alias{[,XPSSample-method}
\alias{c,XPSSample-method}
\alias{XPSapplyshift,XPSSample-method}
\alias{XPSquantify}
\alias{XPSquantify,XPSSample-method}
\alias{XPSpkgCtrl,XPSSample-method}
\title{hasBoundaries}
\usage{
hasBoundaries(object)

\S4method{hasBoundaries}{XPSCoreLine}(object)

hasRegionToFit(object)

\S4method{hasRegionToFit}{XPSCoreLine}(object)

hasBaseline(object)

\S4method{hasBaseline}{XPSCoreLine}(object)

hasComponents(object)

\S4method{hasComponents}{XPSCoreLine}(object)

hasFit(object)

\S4method{hasFit}{XPSCoreLine}(object)

\S4method{show}{XPSCoreLine}(object)

setAsData.Frame(from, to = "data.frame")

\S4method{setAsData.Frame}{XPSCoreLine}(from, to = "data.frame")

setAsMatrix(from, to = "matrix")

\S4method{setAsMatrix}{XPSCoreLine}(from, to = "matrix")

asList(from, select = "all")

\S4method{asList}{XPSCoreLine}(from, select = "all")

sortComponents(object)

\S4method{sortComponents}{XPSCoreLine}(object)

getMaxOfComponents(object)

\S4method{getMaxOfComponents}{XPSCoreLine}(object)

XPSsetRegionToFit(object, limits, ...)

\S4method{XPSsetRegionToFit}{XPSCoreLine}(object, limits, ...)

XPSbaseline(
  object,
  bgtype = c("linear", "shirley", "polynomial", "spline"),
  deg = NULL,
  Wgt = NULL,
  splinePoints = list(x = NULL, y = NULL),
  ...
)

\S4method{XPSbaseline}{XPSCoreLine}(
  object,
  bgtype = c("linear", "shirley", "polynomial", "spline"),
  deg = NULL,
  Wgt = NULL,
  splinePoints = list(x = NULL, y = NULL),
  ...
)

XPSapplyshift(object, shift = NULL)

\S4method{XPSapplyshift}{XPSCoreLine}(object, shift = NULL)

XPSremove(
  object,
  what = c("all", "fit", "components", "baseline", "regionToFit"),
  number
)

\S4method{XPSremove}{XPSCoreLine}(
  object,
  what = c("all", "fit", "components", "baseline", "regionToFit"),
  number
)

XPSsetRSF(object, rsf = NULL)

\S4method{XPSsetRSF}{XPSCoreLine}(object, rsf = NULL)

XPScalc(object, table = TRUE)

\S4method{XPScalc}{XPSCoreLine}(object, table = TRUE)

XPSpkgCtrl(object)

\S4method{XPSpkgCtrl}{XPSCoreLine}(object)

\S4method{plot}{XPSCoreLine,missing}(
  x,
  type = "l",
  ltype = "solid",
  color = "black",
  main = x@Symbol,
  xlim = NULL,
  ylim = NULL,
  labels = TRUE,
  xlab = x@units[1],
  ylab = x@units[2],
  ...
)

XPSresidualPlot(object)

\S4method{XPSresidualPlot}{XPSCoreLine}(object)

\S4method{[}{XPSSample}(x, i, j, ..., drop = FALSE)

\S4method{c}{XPSSample}(x, ...)

\S4method{XPSapplyshift}{XPSSample}(object, shift = NULL)

XPSquantify(object, without = NULL, verbose = TRUE)

\S4method{XPSquantify}{XPSSample}(object, without = NULL, verbose = TRUE)

\S4method{XPSpkgCtrl}{XPSSample}(object)
}
\arguments{
\item{object}{an object of class XPSSample}

\item{from}{an object of class XPSCoreLine}

\item{to}{= matrix object}

\item{select}{one or few or \code{"all"} (default) of \code{c("MAIN", "RTF", "BASE", "COMPONENTS", "FIT")}}

\item{limits}{list with x,y values to limit the region.}

\item{...}{additional parameters}

\item{bgtype}{the baseline function used for background subtraction}

\item{deg}{degree of the polynomial background}

\item{Wgt}{LinearPolynomial weigth in LPShirley, required param in 3P. 4P.Tougaard}

\item{splinePoints}{numeric vector containing the points which will be connected by the spline}

\item{shift}{shift value}

\item{what}{one of "all", "fit", "components", "baseline", "regionToFit"}

\item{number}{in case of \code{what='components'}: the component number will
be reset,\cr if it is missing then all the components will be removed.}

\item{rsf}{the RSF value}

\item{table}{Logic Print Quantification Table if TRUE}

\item{x}{object of class XPSSample to be combined}

\item{type}{character "l", "p", "b" for line, points or both}

\item{ltype}{character, "solid", "dashed"... pattern of the line}

\item{color}{character, "black", "red", "green"... color for the data to be plotted}

\item{main}{character, title of the plot}

\item{xlim}{numeric, range(X) limits of the X-data}

\item{ylim}{numeric, range(Y) limits of the Y-data}

\item{labels}{logical TRUE to plot axis numbers}

\item{xlab}{character "X axis label"}

\item{ylab}{character "Y axis label"}

\item{i}{numeric parameter corresponding to the number of spectra}

\item{j}{dummy numeric parameter}

\item{drop}{logical by default FALSE}

\item{without}{character vector of coreline names which will be not used in the quantification}

\item{verbose}{if TRUE prints the quantification table}
}
\value{
'hasBoundaries' returns a logical vector TRUE if the object has defined boundaries FALSE otherwise

'hasRegionToFit' returns a logical vector TRUE if the object has defined RegionToFit FALSE otherwise

'hasBaseline' returns a logical vector TRUE if the object has a Baseline FALSE otherwise

'hasComponents' returns a logical vector TRUE if the object has defined Fit Components FALSE otherwise

'hasFit' returns a logical vector TRUE if the object has a Best Fit FALSE otherwise

'setAsData.Frame' returns a data.frame object

'setAsData.Frame' returns a data.frame object

'setAsMatrix' returns a matrix object

'setAsMatrix' returns a matrix object

'asList' returns the selected slots of a XPSCoreLine coerced in list format

'asList' returns the selected slots of a XPSCoreLine coerced in list format

list with \code{x,y} value

returns a portion of the CoreLine for a backgrouns subtraction

The Object slot \code{Baseline} will be filled with the selected Bsseline
  and it will be displyed. The baseline function returns an object of class
  \code{baseline}. The x is the same as \code{RegionToFit} x coord. The y coord
  are the baseline values.

The Object slot \code{Baseline}

'XPSapplyshift' returns an XPSCoreLine energy shifted in any of its components 
  (RegionToFit, BaseLine, Fit Components, Best fit)

'XPSremove' returns the object XPSCoreLine with erased slots.

An ASCII file for each XPSCoreLine.

'XPSpkgCtrl' returns an object of class 'XPSCoreLine' with attribute '.GlobalEnv'

XPSSample

XPSSample
}
\description{
S4method 'hasBoundaries' method for objects of class XPSCoreLine.

method to verify an object of class \code{XPSCoreLine}

S4method 'hasRegionToFit' method for objects of class XPSCoreLine.

method to verify an object of class \code{XPSCoreLine}

S4method 'hasBaseline' method for objects of class XPSCoreLine.

method to verify an object of class \code{XPSCoreLine}

S4method 'hasBaseline' method for objects of class XPSCoreLine.

method to verify an object of class \code{XPSCoreLine}

S4method 'hasFit' method for objects of class XPSCoreLine.

method to verify an object of class \code{XPSCoreLine}

Method to show XPSCoreLine elements

setAsData.Frame attempts to coerce an XPSCoreline to a data.frame type. 
 Mainly used for plot function.

method to coerce an object of class 'XPSCoreLine' 
 in an object of class 'data.frame'

setAsMatrix attempts to coerce an XPSCoreline to a matrix type. 
 Mainly used for plot function.

method to coerce an object of class 'XPSCoreLine' in an object of class 'matrix'

asList attempts to coerce its argument to an object of class list. 
 Mainly used for plot function.

method to coerce an object of class 'XPSCoreLine' in an object of class 'list'

Sort Components Method for XPSCoreLine

method to sort Fit Components in ascending energy (binding or kinetic)

Get Max of Components Method for XPSCoreLine

method to define the maximum of Fit Components

Definition of the portion (usually on the x-axis) of the original curve for
  further processing. XPSsetRegionToFit limits usually will be set with the cursor on the 
  curve plot where a \code{Baseline} is needed. Then the \code{RegionToFit} is
  defined as a list of (x,y) data equal to the selected portion of the curve.

method to define the maximum of Fit Components

The RxpsG package provides a class for baselines (class \code{baseline})
  \code{baseline} are values pairs stored in a \code{list}
  and additional parameters are stored in slots.

Calculates the baseline for XPSCoreLine. There is a list of baseline shapes implemented:
  linear, polynomial, spline, Shirley, 2P.Shirley, 3P.Shirley, LP.Shirley,
  2P.Tougaard, 3p.Tougaard, 4P.Tougaard.
  Selection of the appropriate baseline have to be made upon spectral-data properties.

method to generate a Baseline for an object of class 'XPSCoreLine'

Apply the shift value to the X axis of a XPSCoreLine.
  If \code{shift} is NULL the x-axis is set to the original values.

method to energy shift an object of class 'XPSCoreLine'

The function is designed to erase the content of selected slots: \cr \code{"all"} =
  it resets all the \code{slots}. This is the default value if \code{what} is
  missing. See examples. \cr \code{"fit"} = it resets the \code{Fit slot}. \cr
  \code{"components"} = it resets the \code{Components slot} indicated by the
  \code{number}. If \code{number} is missing then all the components will be
  reset.\cr \code{"baseline"} = it resets the \code{Baseline slot}. \cr
  \code{"regionToFit"} = it removes only and any link. \cr

method to erase the content of selected slots an object of class 'XPSCoreLine'

XPSsetRSF sets the RSF value of a XPSCoreLine for quantification.

method to set the RSF of an object of class 'XPSCoreLine'

XPScalc Function to compute the integral intensity for a given XPS-CoreLine.
 Calculation of Integral Intensity of fitting components of a XPSCoreLine.

method to compute the quantification of an object of class 'XPSCoreLine'

XPSpkgCtrl Function to control the attributes of an XPSCoreLine.

method to control the attribute 'package' of an object of class 'XPSCoreLine'

method to plot objects of class XPSCoreLine or XPSSample

XPSresidualPlot Function to plot data and the fit together with the residual difference.

method to plot best fit and data of an object of class 'XPSCoreLine adding residuals

The package provides classes for XPS spectra (class \code{XPSSample}) and
  collections of such lists (class \code{XPSCoreLine}). \code{XPSSample} are
  energy-intensity value pairs stored in a two column \code{list} and several
  additional parameters stored in slots.
  Objects from the Class: Objects can be created by calls of the form \code{new("XPSSample", data, Project, Sample, Comments, User, Filename)}.

get subset of XPSSample

define a method to combine two XPSSamples

definition of method to apply Energy Shifts to objects of class XPSSample
  Apply the shift value to the Binding axis. If \code{shift} is NULL then
  the x-axis will be reset to the original values.

compute the element quantification for the selected XPSSample

method compute the element quantification of objects of class 'XPSSample'

method to controls the XPSSamples attributes
}
\details{
'hasBoundaries' checks if Boundaries are defined for XPSCoreLine objects.

'hasRegionToFit' checks if the RegionToFit is defined for XPSCoreLine objects.

'hasBaseline' checks if Baseline is defined for an XPSCoreLine objects.

'hasComponents' checks if Fit Components are defined for an XPSCoreLine objects.

'hasFit' checks if  Best Fit is defined for an XPSCoreLine objects.
}
\section{Slots}{

\describe{
\item{\code{baseline}}{the Baseline of class Baseline applied to subtract the background}

\item{\code{corrected}}{the background subtracted spectrum}

\item{\code{spectra}}{the original spectrum}

\item{\code{call}}{the called background function}

\item{\code{.Data}}{contains the x,y spectral data}

\item{\code{Project}}{string containing information about the experimental Project}

\item{\code{Sample}}{string containing the complete path to the Raman_spectrum_file}

\item{\code{Comments}}{string containing information about the experiment}

\item{\code{User}}{string containing information about the operator}

\item{\code{Filename}}{string containing the filename}

\item{\code{names}}{string containing the name of the spectra acquired}
}}

\examples{
\dontrun{
 if( hasBoundaries(test[["C1s"]]) ) print(test[["C1s"]]@Boundaries)
}
\dontrun{
 if (hasRegionToFit(test[["C1s"]])) print(length(test[["C1s"]]@RegionToFit$x))
}
\dontrun{
 if( hasBaseline(test[["C1s"]]) ) print(length(test[["C1s"]]@Baseline$y))
}
\dontrun{
 if (hasComponents(test[["C1s"]])) print(length(test[["C1s"]]@Components[[1]]))
}
\dontrun{
 if (hasFit(test[["C1s"]])) print(length(test[["C1s"]]@Fit$y))
}
\dontrun{
 show(test.RData)
}
\dontrun{
 MyDataFrame <- setAsData.Frame(test[["C1s"]], to="data.frame")
}
\dontrun{
 MyMatix <- setAsMatrix(test[["C1s"]], to="matrix")
}
\dontrun{
 MyList <- asList(test[["C1s"]], selected="all")
}
\dontrun{
 sortComponents(test[["C1s"]])
}
\dontrun{
 print(getMaxOfComponents(test[["C1s"]]))
}
\dontrun{
 test[["C1s"]] <- XPSsetRegionToFit(test[["C1s"]], limits=pos)   
}
\dontrun{
test <- new("baseline", ...))
}
\dontrun{
  test[["C1s"]] <- XPSbaseline(test[["C1s"]], "linear")
}
\dontrun{
 test[["C1s"]] <- XPSapplyshift(test[["C1s"]], shift=0.3)
}
\dontrun{
 test[["C1s"]] <- XPSremove(test[["C1s"]], "baseline")
 test[["C1s"]] <- XPSremove(test[["C1s"]], "all") # this reset everything
}
\dontrun{
 test[["C1s"]] <- XPSsetRSF(test[["C1s"]], rsf=0.278)
}
\dontrun{
 test[["C1s"]] <- XPScalc(test[["C1s"]], table=TRUE) #TRUE=prints the quantification
}
\dontrun{
 test[["C1s"]] <- XPSpkgCtrl(test[["C1s"]])
}
\dontrun{
 plot(test[["C1s"]]) #plot the XPSCoreline
}
\dontrun{
 XPSresidualPlot(test[["C1s"]]) #add residuals when plotting the XPSCoreline Fit
}
\dontrun{
SiOx <- new("XPSSample",project="test on diamond implantation",comments="Si - Implantation dose 10^14")
}
\dontrun{
 XPSSampTot <- c(XPSSample1, XPSsample2)
}
\dontrun{
test <- XPSapplyshift(test, shift=0.3 ) #apply shift =0.3 to the  test XPSSample
}
\dontrun{
 QuantData <- XPSquantify(test, without=NULL, verbose=TRUE ) #computes the  quantification for the  test XPSSample
}
\dontrun{
 test <- XPSpkgCtrl(test) #controls the  attributes of the  test XPSSample
}
}
\seealso{
\link{XPSbaseline}

\linkS4class{XPSCoreLine}

\link{write.table}, \link{write.csv}, \link{write.csv2}
}
\keyword{classes}
